# https://github.com/ftarlao/check-media-integrity
# ffmpeg-python==0.1.17
# future==0.17.1
# Pillow-SIMD==5.3.0.post0
# PyPDF2==1.26.0
# Wand==0.4.5
# ImageMagick-6.9.13-7-Q16-HDRI-x64-dll.exe
import os
import sys
from multiprocessing import Queue, Process
from queue import Empty
import zlib

from PyQt5.QtCore import QUrl
from PyQt5.QtGui import QDesktopServices


def open_current_sfv(dir):
    if os.path.isdir(dir):
        dirname = os.path.basename(dir)
        sfvname = dirname + '.sfv'
        sfvpath = os.path.join(dir, sfvname)
        if os.path.exists(sfvpath):
            QDesktopServices.openUrl(QUrl.fromLocalFile(sfvpath))


def is_svf_exist(dir):
    if os.path.isdir(dir):
        dirname = os.path.basename(dir)
        sfvname = dirname + '.sfv'
        sfvpath = os.path.join(dir, sfvname)
        if os.path.exists(sfvpath):
            return True
    return False


def is_exclude_file(name):
    if name.endswith('.sfv'):
        return True
    if name.endswith('.ffs_db'):
        return True
    if 'non_image_files' in name or 'intact_images' in name or 'corrupted_images' in name:
        return True
    return False


def is_exclude_sfv_line(line):
    if 'Generated by WIN-SFV32' in line or 'Compatible: EF CheckSum Manager' in line:
        return True
    if 'non_image_files' in line or 'intact_images' in line or 'corrupted_images' in line:
        return True
    return False


def create_sfv(svf_located_folder_apath):
    file_list = os.listdir(svf_located_folder_apath)
    files_only_set = set()
    for f in file_list:
        if os.path.isfile(os.path.join(svf_located_folder_apath, f)):
            files_only_set.add(os.path.join(svf_located_folder_apath, f))

    if len(files_only_set) > 0:
        sfv_file_apath = os.path.join(svf_located_folder_apath, os.path.basename(svf_located_folder_apath) + '.sfv')
        with open(sfv_file_apath, 'w', encoding='utf-8') as svf:
            print(f"{sfv_file_apath} 不存在，创建中")
            for file in files_only_set:
                file_name = os.path.basename(file)
                if is_exclude_file(file_name):
                    continue
                with open(file, 'rb') as f:
                    content = f.read()
                    crc32_calculated = zlib.crc32(content)
                    line = file_name + " " + '{:08x}'.format(crc32_calculated & 0xFFFFFFFF) + "\n"
                    svf.write(line)


def process_sfv_file(svf_file_apath):
    svf_located_folder_apath = os.path.dirname(svf_file_apath)
    file_list = os.listdir(svf_located_folder_apath)
    files_only_set = set()
    for f in file_list:
        if os.path.isfile(os.path.join(svf_located_folder_apath, f)):
            files_only_set.add(os.path.join(svf_located_folder_apath, f))

    with open(svf_file_apath, 'r', encoding='utf-8') as file:

        for line in file:

            if is_exclude_sfv_line(line):
                continue

            filename, crc32_value = line.rsplit(' ', 1)

            crc32_value = crc32_value.rstrip('\n')

            filename = os.path.join(os.path.dirname(svf_file_apath), filename)  # 获取文件的绝对路径

            if filename.endswith(".sfv"):
                continue
            if os.path.exists(filename):
                files_only_set.remove(filename)
                with open(filename, 'rb') as f:
                    content = f.read()
                    crc32_calculated = zlib.crc32(content)
                if '{:08x}'.format(crc32_calculated & 0xFFFFFFFF) == crc32_value.lower():
                    # print(f"文件 '{filename}' 的CRC32值验证通过")
                    pass
                else:
                    print(f"文件 '{filename}' 的CRC32值验证未通过")
            else:
                print(f"文件 '{filename}' 不存在")

    if len(files_only_set) > 0:
        with open(svf_file_apath, 'a', encoding='utf-8') as svf:
            for file in files_only_set:
                file_name = os.path.basename(file)
                if file_name.endswith(".sfv"):
                    continue
                with open(file, 'rb') as f:
                    content = f.read()
                    crc32_calculated = zlib.crc32(content)
                    line = file_name + " " + '{:08x}'.format(crc32_calculated & 0xFFFFFFFF) + "\n"
                    svf.write(line)


def process_sfv_files_in_directory(directory):
    flag = 0
    for item in os.listdir(directory):
        if item.endswith('.sfv'):
            sfv_file_path = os.path.join(directory, item)
            flag = 1
            process_sfv_file(sfv_file_path)
    if flag == 0:
        create_sfv(directory)


def worker(in_queue, out_queue):
    try:
        while True:
            full_folder_name = in_queue.get(block=True, timeout=3)
            process_sfv_files_in_directory(full_folder_name)
            out_queue.put(1)
    except Empty:
        # print("Closing parallel worker, the worker has no more tasks to perform")
        return
    except Exception as e:
        print("Parallel worker got unexpected error", str(e))
        sys.exit(1)


def calculate_crc32_in_folder_mu(main_directory):
    """
    校检输入目录下的sfv文件中存储的crc32值是否和文件计算出来的一致（多线程）

    如果文件不存在对应crc32，则计算并存入sfv文件中

    如果sfv文件不存在，则创建新sfv文件，并计算文件的crc32存入sfv文件中

    :param main_directory:
    :param thread_count:
    :return:
    """

    # 获取CPU核心数
    cpu_cores = os.cpu_count()
    thread_count = cpu_cores // 2

    task_queue = Queue()
    out_queue = Queue()
    pre_count = 0
    count = 0

    # 构建要处理的文件夹列表
    task_queue.put(main_directory)
    pre_count += 1
    for root, dirs, files in os.walk(main_directory):

        pre_count += len(dirs)

        for folder in dirs:
            task_queue.put(os.path.join(root, folder))

    for i in range(thread_count):
        p = Process(target=worker, args=(task_queue, out_queue))
        p.start()

    # consume the outcome
    try:
        for j in range(pre_count):
            count += 1
            out_queue.get(block=True, timeout=120)
            # visualization logs and stats
            print("Number of processed folder ", count)
    except Empty as e:
        print("Waiting other results for too much time, perhaps you have to raise the timeout", e.message)
    print("\n**CRC32 Task completed**\n")


if __name__ == '__main__':
    calculate_crc32_in_folder_mu(r"E:\BaiduNetdiskDownload")